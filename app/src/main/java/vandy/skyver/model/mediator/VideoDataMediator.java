package vandy.skyver.model.mediator;

import java.io.File;
import java.util.ArrayList;
import java.util.List;

import retrofit.RestAdapter;
import retrofit.client.Response;
import retrofit.mime.TypedFile;

import vandy.skyver.model.mediator.webdata.Video;
import vandy.skyver.model.mediator.webdata.VideoSvc;
import vandy.skyver.model.mediator.webdata.VideoSvcApi;
import vandy.skyver.model.mediator.webdata.VideoStatus;
import vandy.skyver.model.mediator.webdata.VideoStatus.VideoState;
import vandy.skyver.provider.ContentProviderHelper;
import vandy.skyver.utils.Constants;
import vandy.skyver.utils.VideoMediaStoreUtils;
import vandy.skyver.utils.VideoStorageUtils;

import android.app.Application;
import android.content.Context;
import android.net.Uri;
import android.widget.Toast;

import com.google.common.collect.Lists;

/**
 * Mediates communication between the Video Service and the local
 * storage on the Android device.  The methods in this class block, so
 * they should be called from a background thread (e.g., via an
 * AsyncTask).
 */
public class VideoDataMediator {
    /**
     * Status code to indicate that file is successfully
     * uploaded.
     */
    public static final String STATUS_UPLOAD_SUCCESSFUL =
        "Upload succeeded";
    
    /**
     * Status code to indicate that file upload failed 
     * due to large video size.
     */
    public static final String STATUS_UPLOAD_ERROR_FILE_TOO_LARGE =
        "Upload failed: File too big";
    
    /**
     * Status code to indicate that file upload failed.
     */
    public static final String STATUS_UPLOAD_ERROR =
        "Upload failed";

    /**
     * Status code to indicate that file is successfully
     * downloaded.
     */
    public static final String STATUS_DOWNLOAD_SUCCESSFUL =
            "Download succeeded";

    /**
     * Status code to indicate that file upload failed.
     */
    public static final String STATUS_DOWNLOAD_ERROR =
            "Download failed";
    
    /**
     * Defines methods that communicate with the Video Service.
     */
    private VideoSvcApi mVideoSvcApi;

    private ContentProviderHelper mContProvider;

    private Context context;
    /**
     * Constructor that initializes the VideoDataMediator.
     * 
     * @param context
     */
    public VideoDataMediator(Context context) {
        // Initialize the VideoSvcApi.
        this.context = context;
        mVideoSvcApi = VideoSvc.getOrShowLogin(context);
    }

    /**
     * Uploads the Video having the given Id.  This Id is the Id of
     * Video in Android Video Content Provider.
     * 
     * @param videoId
     *            Id of the Video to be uploaded.
     *
     * @return A String indicating the status of the video upload operation.
     */
    public String uploadVideo(Uri videoUri) {
        // Get the path of video file from videoUri.
        String filePath = VideoMediaStoreUtils.getPath(context,
                                                       videoUri);
        
        // Get the Video from Android Video Content Provider having
        // the given filePath.
        Video androidVideo = 
            VideoMediaStoreUtils.getVideo(context,
                    filePath);
        
        // Check if any such Video exists in Android Video Content
        // Provider.
        if (androidVideo != null) {
            // Add the metadata of the Video to the Video Service and
            // get the resulting Video that contains additional
            // meta-data (e.g., Id and ContentType) generated by the
            // Video Service.

            //androidVideo.setDataUrl(videoUri.toString()); // SET URL///////////////////////

            Video receivedVideo = 
                mVideoSvcApi.addVideo(androidVideo);

            // Check if the Video Service returned any Video metadata.
            if (receivedVideo != null) {
                // Prepare to Upload the Video data.
                              
                // Create an instance of the file to upload.
                File videoFile = new File(filePath);
                      
                // Check if the file size is less than the size of the
                // video that can be uploaded to the Video Service.
                if (videoFile.length() < Constants.MAX_SIZE_MEGA_BYTE) {
                    // Upload the Video data to the Video Service and get the
                    // status of the uploaded video data.
                    VideoStatus status =
                        mVideoSvcApi.setVideoData
                            (receivedVideo.getId(),
                             new TypedFile(receivedVideo.getContentType(),
                                           videoFile));

                    // Check if the Status of the Video is ready or not.
                    if (status.getState() == VideoState.READY) {
                        // Video successfully uploaded.
                        // PUT IN OUR CONTENT PROIVDER
                        receivedVideo.setUrl(videoUri.toString());///////////////
                        mContProvider = new ContentProviderHelper(context.getApplicationContext()) ;////////
                        mContProvider.putVideo(receivedVideo);////////////
                        return STATUS_UPLOAD_SUCCESSFUL;
                    }
                } else 
                    // Video can't be uploaded due to large video size.
                    return STATUS_UPLOAD_ERROR_FILE_TOO_LARGE;
            }
        }

        // Error occured while uploading the video.
        return STATUS_UPLOAD_ERROR;
    }

    public String downloadVideo( long id, String name) {

        Response response = mVideoSvcApi.getVideoData(id);
        if(response.getStatus() == 404)
            Toast.makeText(context, "Can NOT download - 404", Toast.LENGTH_LONG).show();
        //assertEquals(200, response.getStatus());

        //InputStream videoData = response.getBody().in();
        //byte[] originalFile = IOUtils.toByteArray(new FileInputStream(testVideoData));

        File fl = VideoStorageUtils.storeVideoInExternalDirectory(context, response, name);

        if(fl.exists()){

            mContProvider = new ContentProviderHelper(context);
            Video vid = mContProvider.getVideoById(id);

            if(vid != null){
                vid.setUrl(Uri.fromFile(fl).toString());
                mContProvider.updateVideo(vid);
            }
            else{

                    //vid = VideoMediaStoreUtils.getVideo(cnt, fl.getCanonicalPath());//getPath toString getAbsolutePath getCanonicalPath

                List<Video> lst = getVideoList();
                vid = lst.get((int)id);
                vid.setUrl(Uri.fromFile(fl).toString());

                mContProvider.putVideo(vid);
            }

            //mContProvider.updateUriById(vId, Uri.fromFile(fl));
            return STATUS_DOWNLOAD_SUCCESSFUL;
        }
        else
            return STATUS_DOWNLOAD_ERROR;


    }

    public double setRating( long id, int setRate){


        AverageVideoRating avr = mVideoSvcApi.rateVideo(id, setRate);
        double resultRate = avr.getRating();

        mContProvider = new ContentProviderHelper(context);
        Video v = mContProvider.getVideoById(id);
        if(v != null){

            v.setStarRating(resultRate);
            mContProvider.updateVideo(v);
        }

        return resultRate;
    }

    /**
     * Get the List of Videos from Video Service.
     *
     * @return the List of Videos from Server or null if there is
     *         failure in getting the Videos.
     */
    public List<Video> getVideoList() {
        return Lists.newArrayList( mVideoSvcApi.getVideoList());
    }
}
